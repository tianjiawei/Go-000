#### GoLong Error学习心得

- 学习之前工作中只是知道error一定要处理，可能在value不重要的情况下，
偶尔还会用 '_' 来忽略错误，总之就是没有固定的规范，也没有体会到error的价值，
怎么去优雅的写error更是没有思考过，不过在实践中也踩了一些坑
，比如为了方便排错，加上全局的recover等。

- 通过毛大的细心诙谐的讲解，对代码的错误，也有了一定的认识和思考，下面总结一下本周课程的收获：
1. panic不能随便用，因为一旦Panic，就意味着程序挂了，但是也不是不可以用，
有如下几个必须用的地方：初始化数据库、初始化配置文件等场景下，
如果此初始化失败，会导致系统无法启动，或者启动之后，无法正常运行，影响业务逻辑等情况，
那么则必须用Panic。当然，还有一些逼不得已需要玩火的场景可以临时的用一下（例如：毛大说的读多写少，
并且写失败也不会影响业务逻辑的情况，终极解决方案还是要恢复DB正常）。
2. 必须在程序主流程中增加recover，来捕获未知的Panic（比如空指针、数组越界等），
一方面防止程序崩溃，另一方面也方便我们收集trace log，来进行排错。
3. 在程序中在主协程之外开启goroutine的话，需要统一封装一个开启goroutine的方法，
用于recover当前goroutine的Panic，并收集trace日志，防止野生的goroutine导致主goroutine崩溃，
这样则能大大减少程序崩溃的风险，并且也更利于我们日常的去fix bug。
4. 对于error的处理，首先是 error必须处理，未处理error的value是不可用的。
其次，就是error应该如何处理，error整体来说分为2类：1、底层包，就是类似gorm这种公用的包，
error应该有明确的定义，直接返回error就行了，无需进行进一步的处理，
以免造成和调用者重复处理error等情况。2、业务层面的代码，就应该利用类似 github.com/pkg/errors
 的包，对error进行统一处理，好处是：处理简单，无需每层都对error具体内容进行判断/处理，
 只需要返回到顶层(main函数)，然后进行统一处理，代码也更显的优雅。多人合作，也有统一的标准。
 - Go语言语法很简单，并没有像java那样的规范，所以在工程化的过程中，我们除了实现功能之外，更要多一点思考，
 通过踩坑，或者学习别人踩坑经验，多总结最佳实践。
 - 官方文档是最好的资料，一定要先试着去看官方文档，从一手资料入手，不要畏惧全英文。